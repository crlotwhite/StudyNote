역할:
당신은 숙련된 C++/JUCE 오디오 플러그인 엔지니어입니다. 목표는 “폴리 서브트랙티브 신디사이저(VST3) MVP”를 구현하는 것입니다. 결과물은 로컬에서 빌드/실행 가능한 코드(프로젝트 파일 포함)여야 하며, 오디오 스레드 안전성과 재현성을 최우선으로 합니다.

프로젝트 목표(요약):
- JUCE 기반 VST3 신디 플러그인 MVP 구현
- 2 OSC + Noise + Filter(SVF) + Amp ADSR + Filter ADSR + LFO1
- Unison(선택) + Stereo spread(선택)
- Global FX: Delay + Reverb(간단)
- Macro 6개(Brightness/Warmth/Punch/Motion/Width/Space)로 내부 파라미터를 매핑
- APVTS(AudioProcessorValueTreeState)로 모든 파라미터 관리, 프리셋 저장/복원 가능
- 오디오 스레드에서 네트워크/파일 I/O/동적 할당 최소화
- 향후 LLM(예: LM Studio/Ollama) 연동을 위해 “프리셋 JSON” 적용 지점을 설계(이번 MVP에서는 네트워크 호출 구현은 하지 않아도 됨)

필수 산출물:
1) JUCE 플러그인 프로젝트(권장: Projucer 없이 CMake 기반, JUCE FetchContent 사용)
2) 소스 코드 파일 구조(예: Source/ 폴더)
3) README.md
   - 빌드 방법(Windows 기준, Visual Studio + CMake)
   - 플러그인 스캔/테스트 방법(간단)
   - 주요 기능과 파라미터 설명
4) 기본 프리셋 10개(예: Pad/Lead/Pluck/Bass 포함). 최소한 코드로 로드 가능한 형태(ValueTree 또는 JSON 리소스)로 제공.

기능 요구사항(정확):
A. Voice(폴리):
- Poly voice allocator 사용(juce::Synthesiser 기반 또는 DSP 기반 커스텀)
- OSC1/OSC2:
  - 파형: sine/tri/saw/square (PWM은 옵션)
  - OSC2: semitone(-12~+12), detune(0~30cent) 옵션
- Noise: 화이트 노이즈 gain
- Mixer: osc1/osc2/noise 레벨 합성
- Filter: State Variable Filter(SVF) 권장
  - 타입: LP/BP/HP
  - cutoff(20~20000), resonance(0~1), drive(소프트 클리핑/사츄레이션)
- Envelopes:
  - Amp ADSR (A/D/S/R)
  - Filter ADSR (A/D/S/R + envAmount)
- LFO1:
  - shape: sine/tri
  - rate: 0.05~20Hz (tempo sync는 옵션)
  - depth
- Mod routing(최소):
  - LFO1 → cutoff depth
  - LFO1 → pitch depth(비브라토, 옵션)
  - Filter Env → cutoff amount

B. Global FX(간단):
- Delay: time(ms 또는 sync 옵션), feedback, mix
- Reverb: size, damp, mix (간단 구현)
- Master: gain, limiter(가벼운 보호용, 옵션)

C. Macro 6개(0~1 정규화):
- Brightness: cutoff↑, filter env amount↑, osc 밝은 파형 비중↑, reverb damp↓(더 밝게)
- Warmth: drive↑, cutoff 약간↓, resonance 과도 시↓, detune 아주 미세↑
- Punch: amp attack↓, decay↓, filter env attack↓, env amount↑
- Motion: LFO rate↑, LFO→cutoff depth↑, (선택) stereo/pan 모션
- Width: unison voices/spread↑, detune↑, reverb mix 소폭↑
- Space: delay mix/time↑, reverb mix/size↑
요구: Macro가 내부 파라미터 3~6개를 “과하지 않게” 움직이도록 매핑. 모든 매핑은 범위 클램프 + 스무딩 적용.

D. UI:
- 최소 UI: 슬라이더/콤보박스/버튼으로 파라미터 조정 가능
- Macro 6개는 상단에 크게 배치(사용자 경험 중심)
- 세부 파라미터는 탭/그룹으로 정리(osc/filter/env/lfo/fx)

E. Preset:
- APVTS state 저장/복원 구현
- 기본 프리셋 10개 제공(코드/리소스 형태)
- “프리셋 적용 시 클릭/팝”을 줄이기 위해 램핑(스무딩) 전략 적용(필수)

오디오 스레드 안전/성능 규칙(필수):
- processBlock에서는 네트워크/디스크 I/O 금지
- 동적 할당 최소화(가능하면 prepareToPlay에서 할당)
- 파라미터 변화는 스무딩(juce::SmoothedValue 등)로 처리
- 폴리 보이스 수 기본 8~16(설정 가능), CPU 과부하 방지

향후 LLM 연동을 위한 설계(이번에 “지점”만 만들어두기):
- “PresetPatch” 데이터 구조를 정의하고, JSON을 파싱해 내부 파라미터에 적용하는 함수를 분리해둔다.
- 이번 단계에서는 JSON 파서(예: juce::var/JSON)로 “로컬 문자열”을 적용하는 데모 함수만 있어도 된다.
- LLM 호출 자체(HTTP)는 구현하지 않는다. 단, 호출할 수 있도록 인터페이스/스레딩 위치(UI thread → background → apply on message thread) 설계 주석을 남긴다.

코드 품질 요구:
- 파일/클래스 분리: Engine(voice), DSP modules(osc/filter/env/lfo), FX, UI, Preset
- 명확한 네이밍, 주석(특히 스레드 관련), 에러 처리
- Windows에서 빌드 가능한 CMake 구성

작업 방식(중요):
- 1) 먼저 “소리가 나는 최소 악기(모노)”부터 만들고
- 2) 폴리로 확장하고
- 3) LFO/Filter Env/Fx
- 4) Macro 매핑
- 5) 프리셋/저장복원
순서로 구현하라. 각 단계마다 빌드가 깨지지 않게 커밋 단위로 진행(커밋 메시지 제안 포함).

최종 확인(Acceptance Criteria):
- DAW/플러그인 호스트에서 음이 정상적으로 나고(폴리), 기본 프리셋 10개가 로드된다.
- Macro 6개를 움직이면 소리가 “직관적으로” 변한다(밝기/따뜻함/공간감/모션 등).
- 파라미터를 급격히 바꿔도 클릭/팝이 심하지 않다(스무딩 적용).
- 프로젝트가 README의 절차대로 빌드된다.

출력 형식:
- 생성/수정한 파일 목록과 디렉터리 트리
- 각 파일의 핵심 코드(가능하면 실제 파일 생성)
- README 포함
- “다음에 LLM을 붙이는 방법”에 대한 짧은 TODO 섹션
