## 1. MCP 도구 개발이 의미하는 것

> **MCP 도구를 만든다는 것 = “AI + 플랫폼 + 도메인 전문성”을 동시에 다루는 엔지니어라는 증거**

단순히 LLM을 “사용”하는 수준이 아니라,  
LLM이 활용할 **도구 레이어를 직접 설계·구현하는 역할**을 맡게 됨.

- LLM이 호출하는 **툴 인터페이스(API)** 설계
- 외부 시스템과 연결하는 **플랫폼 레이어** 구현
- 어떤 부분을 LLM에게 맡기고, 어떤 부분을 도구에 맡길지 **워크플로우 설계**

→ 이건 “프롬프트 잘 쓰는 사람”이 아니라,  
**“AI 에이전트 플랫폼을 구성할 줄 아는 엔지니어” 포지션에 가까움.**

---

## 2. 기술 스택 관점에서 얻는 것

### 2.1. 자연스럽게 쌓이는 스킬셋

MCP 도구를 1~2개만 만들어도 다음 역량이 드러남:

- **API·툴 설계 능력**
  - 입력/출력 스키마(JSON Schema) 정의
  - 명확한 contract, 에러 케이스 정의
- **시스템/플랫폼 감각**
  - 인증/권한 관리 (API 키, OAuth, 시크릿 관리)
  - 타임아웃, 재시도, rate limit 등 운영 레벨 설계
- **LLM 협업 인터페이스 설계**
  - LLM이 이해하기 쉬운 툴 이름·설명·파라미터 설계
  - 자연어 시나리오를 “툴 호출 시퀀스”로 쪼개는 능력

→ JD상에서 말하는 “agents / tool use / AI platform / orchestration”과 직접 연결되는 영역.

### 2.2. 포지션 관점에서의 업그레이드

- “주니어 AI 엔지니어” →  
  **“에이전트/툴링/플랫폼까지 이해하는 AI 엔지니어”**
- 또는  
  **“DevTools/에이전트 인프라에 강한 AI 엔지니어”**로 포지셔닝 가능

---

## 3. 내 도메인(TTS/SVS, 오디오)과 MCP의 시너지

나는 이미:

- DiffSinger / VITS / StyleTTS / g2p / aligner / energy predictor
- RunPod / TensorDock / 학습 비용 최적화
- 오디오 DSP + TTS/SVS 파이프라인

같은 **오디오/TTS/SVS 도메인에 깊이 들어와 있는 상태**.

여기에 MCP를 붙이면:

> **“LLM/에이전트가 TTS/SVS 파이프라인을 이해하고 직접 다루게 해주는 사람”** 이 됨.

예시 MCP 아이디어:

- `svs-dataset-mcp`  
  - 데이터셋 라벨/align 상태 조회·검증
- `svs-loudness-mcp`  
  - `loudness_stats_*.csv`를 읽고 분포/에너지 문제 분석
- `tts-training-mcp`  
  - RunPod/TensorDock 등에 학습 잡 올리고 상태/비용 모니터링

이런 MCP를 만들면:

1. 내 실험/연구 워크플로우가 직접적으로 편해지고
2. **오디오 도메인 지식을 에이전트 도구로 캡슐화할 수 있는 희소한 엔지니어**라는 포지션을 가지게 됨.

→ 음성/TTS 회사, DAW/플러그인 회사, 크리에이터 툴 회사 등에 어필하기 좋음.

---

## 4. JUCE MCP 같은 “개발자 도구 MCP”의 커리어 가치

`juce-devtools-mcp` 같은 MCP는 사실상:

> **“AI와 함께 동작하는 DevTools를 직접 설계한 경험”**

으로 해석될 수 있음.

포인트:

- JUCE 프로젝트 구조 인식 (CMake/Projucer)
- 빌드/테스트 실행 및 로그 수집
- `AudioProcessor`/`Component` 구조 스캔
- 실시간 오디오 안전 패턴 검사 등

이런 MCP를 구현했다는 것은 곧:

- IDE/에디터 + AI + 특정 프레임워크(JUCE)를 엮은  
  **“에이전트 기반 개발 환경”을 설계했다는 것**이고,
- 아래 포지션들과 바로 연결됨:
  - AI IDE / 에디터 팀 (Cursor, Windsurf, Kiro, Zed 등)
  - 사내 개발자 플랫폼 / DevEx 팀
  - 멀티에이전트/오케스트레이션 플랫폼 팀

→ 내가 자주 고민하던 “코딩 에이전트/오케스트레이션 쪽으로 가고 싶다”와 직접적으로 이어지는 스택.

---

## 5. 포트폴리오 관점에서의 장점

MCP 도구는 **구조가 명확해서 설명하기 좋다.**

### 5.1. 예시 스토리 구조

예: `juce-devtools-mcp`

- 문제:
  - LLM이 JUCE 프로젝트를 이해하지 못해서, 코드 생성·리팩터링 품질이 들쭉날쭉함.
- 해결:
  - JUCE 프로젝트를 인식하고(CMake/Projucer),
  - 빌드/로그를 MCP 툴로 제공하고,
  - 주요 AudioProcessor/Component 구조를 정리해서 LLM에 전달하는 MCP 서버 구현.
- 가치:
  - 에이전트가 “프로젝트 문맥을 이해한 상태에서” 리팩터링/추가 기능 구현을 제안할 수 있게 됨.
- 기술:
  - TypeScript/Node, MCP 프로토콜, CMake, JUCE 구조 이해, 정적 분석(기초)

예: `svs-loudness-mcp`

- 문제:
  - 라우드니스/에너지 문제 분석을 할 때마다 CSV를 직접 열어 보고 수동으로 그래프를 봐야 함.
- 해결:
  - `loudness_stats_*.csv`를 읽고 통계/분포를 계산해 LLM에 넘기는 MCP 서버 구현.
- 가치:
  - 실험 반복 속도가 빨라지고, LLM이 분석/리포트를 자동화해 줌.
- 기술:
  - Python/TS, CSV 처리, 간단한 통계/시각화, TTS/SVS 파이프라인 이해

→ 이런 식으로 **“문제 → MCP 설계 → 구현 → 얻은 효과”** 흐름을 그대로 포폴/이력서에 넣기 좋음.

### 5.2. 채용 측에서 보기 좋은 점

- 단순히 “LLM 써봤다” 수준이 아니라,
- **“LLM이 쓰는 툴을 스스로 설계·구현하고, 실제 워크플로우를 바꿔본 사람”**이라는 증거가 됨.

실제 상용 서비스에서는:

- 다양한 외부 시스템과 LLM을 붙이는 일이 대부분이라서,
- MCP 도구 구현 경험은 실무와 거의 1:1로 연결됨.

---

## 6. 실질적인 커리어 활용 플랜

### 6.1. 해야 할 일 정리

1. **내 도메인에 맞는 MCP 1~2개 선정**
   - 예: `juce-devtools-mcp` + `svs-loudness-mcp`
2. 각 MCP에 대해:
   - README + 설계 요약 + 기능 설명 + 예시 호출 작성
3. **내 실제 작업 흐름에 붙이기**
   - Kiro, Cursor, 기타 IDE에서 MCP를 등록하고,
   - “이 MCP 덕분에 워크플로우가 어떻게 바뀌었는지” 경험/스크린샷/노트 남기기
4. 이직·지원 시:
   - “MCP 도구 개발 경험”을 중심으로
     - 설계 의도
     - 기술 스택
     - 도메인 지식
     - 얻은 인사이트
   - 를 스토리텔링

### 6.2. 나에게 주는 최종 효과 요약

- 포지셔닝:
  - 단순 LLM 사용자 → **에이전트/툴링 엔지니어**
- 도메인:
  - 오디오/TTS/SVS 전문성 + 에이전트 툴 설계 능력의 희소한 조합
- DevTools:
  - IDE/플러그인/에이전트 플랫폼 쪽으로 자연스럽게 이어지는 커리어 루트 확보

---

## 7. 한 줄 요약

> **MCP 도구 개발은 “내 도메인(TTS/SVS, JUCE, DevTools)을 에이전트가 직접 활용할 수 있는 형태로 캡슐화하는 작업”이고,  
> 이것 자체가 커리어상 매우 강한 차별화 포인트가 된다.**